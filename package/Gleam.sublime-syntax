%YAML 1.2
---
version: 2

file_extensions:
  - gleam

scope: source.gleam

variables:
  discard: '_[_0-9a-z]*'
  name: '[a-z][_0-9a-z]*'
  upname: '[A-Z][0-9a-zA-Z]*'
  keyword: 'as|assert|case|const|fn|import|let|opaque|panic|pub|todo|type|use'
  reserved_keyword: 'auto|delegate|derive|echo|else|implement|macro|test'

contexts:
  # Prepended to all scopes by default.
  prototype:
    - include: comment

  # The initial scope.
  main:
    - include: ws-lf
    - include: import
    - include: pub
    - include: const
    - include: req-main

  # ==== Utilities

  # Consumes any sequence of whitespace characters, excluding newlines.
  #
  # The compiler generally allows whitespace _including_ newlines between all
  # tokens, but there are many cases where a newline would be unexpected in
  # well-formatted code, and allowing them in this syntax would cause flickering
  # during typing.
  ws:
    - match: \s+

  # As `ws` but includes newlines.
  ws-lf:
    - match: \s
      push:
        - match: (?=\S)
          pop: true

  # Included in contexts that match a `name` which should not be a keyword.
  no-keyword:
    - match: '{{keyword}}|{{reserved_keyword}}'
      scope: invalid.illegal.gleam
      pop: true

  # Unconditionally pops when reached. Included as the final match in contexts
  # that represent an optional syntax construct, allowing sequences of optional
  # elements to be parsed by stacking their contexts in order.
  opt:
    - match: ''
      pop: true

  # Included as the final match in contexts that represent a required syntax
  # construct. Normally identical to `opt`, since we should keep parsing the
  # file as best we can even if a required element is missing (very often the
  # case while editing code!) â€” but keeping it separate means it can be easily
  # swapped out for a "stricter" version when needed, e.g. for debugging.
  req:
    - match: ''
      pop: true

  # Like `req` for contexts that represent an "item" in a list-like construct,
  # where the list is ended by a closing brace. Instead of popping immediately,
  # which would ultimately abandon parsing of the entire list, we first try to
  # skip ahead to the end of the current item so we have a chance to continue
  # parsing later items.
  req-item-brace:
    - match: ''
      set:
        - match: (?=[,}])
          pop: true

  # Like `req-item-brace` but the list ends with a bracket.
  req-item-bracket:
    - match: ''
      set:
        - match: (?=[,\]])
          pop: true

  # Like `req-item-brace` but the list ends with a paren.
  req-item-paren:
    - match: ''
      set:
        - match: (?=[,)])
          pop: true

  # ==== Comments

  # According to the naming guide, "multi-line comments used as documentation"
  # should use `comment.block.documentation`. Unknown whether this has any real
  # effect in editors, or whether the scope should be applied to the entire doc
  # comment "unbroken" by line breaks (which we don't do here).
  #
  # Ref: https://www.sublimetext.com/docs/scope_naming.html#comment

  comment:
    - match: ///?/?
      scope: punctuation.definition.comment.line.gleam
      push:
        - meta_scope: comment.line.gleam
        - match: $
          pop: true

  # ==== Import statements

  import:
    - match: import\b
      scope: keyword.control.import.gleam
      branch_point: import
      branch:
        - import--name
        - import--aliased-name

  import--name:
    - include: ws
    - include: no-keyword
    - match: '({{name}})(/)'
      captures:
        1: entity.other.module.gleam
        2: punctuation.accessor.gleam
    - match: '{{name}}'
      scope: entity.name.namespace.gleam
      set:
        - import--no-alias
        - import--unqualified
    - include: req

  import--aliased-name:
    - include: ws
    - include: no-keyword
    - match: '({{name}})(/)'
      captures:
        1: entity.other.module.gleam
        2: punctuation.accessor.gleam
    - match: '{{name}}'
      scope: entity.other.aliased.namespace.gleam
      set:
        - import--alias
        - import--unqualified
    - include: req

  import--unqualified:
    - match: (\.)({)
      captures:
        1: punctuation.accessor.gleam
        2: punctuation.definition.generic.begin.gleam
      set: import--unqualified--pre
    - include: opt

  # Reparse as an aliased import if we encounter an `as`. This is needed since
  # we try the "unaliased" branch first, per the documentation's advice that
  # for best performance, branches should be tried in order of how likely they
  # are to be taken.
  import--no-alias:
    - include: ws-lf
    - match: as
      fail: import
    - match: ''
      pop: true

  import--alias:
    - include: ws-lf
    - match: as
      scope: keyword.other.alias.gleam
      set:
        - include: ws
        - match: '{{name}}'
          scope: entity.name.namespace.gleam
          pop: true
        - match: '{{discard}}'
          scope: comment.other.discard.gleam
          pop: true
        - include: req
    - include: req

  import--unqualified--pre:
    - include: ws-lf
    - include: end-brace
    - match: ''
      set:
        - import--unqualified--post
        - import--unqualified--item

  import--unqualified--item:
    - include: ws-lf
    - match: 'type'
      scope: storage.type.gleam
      set: import--unqualified--item--type
    - match: '(?=[A-Z])'
      set: import--unqualified--item--variant
    - match: '(?=[a-z])'
      set: import--unqualified--item--constant
    - include: req-item-brace

  # Rather than branching and multiplying the number of states, we cheat a bit
  # and include both an aliased name token and the following `as` token in the
  # same pattern. These being on separate lines is syntactically valid but very
  # unlikely.

  import--unqualified--item--type:
    - include: ws
    - match: '({{upname}})\s+(as)'
      captures:
        1: entity.other.aliased.type.gleam
        2: keyword.other.alias.gleam
      set: import--unqualified--item--type--alias
    - match: '{{upname}}'
      scope: entity.name.type.gleam
      pop: true
    - include: req-item-brace

  import--unqualified--item--type--alias:
    - include: ws
    - match: '{{upname}}'
      scope: entity.name.type.gleam
      pop: true
    - include: req-item-brace

  import--unqualified--item--variant:
    - include: ws
    - match: '({{upname}})\s+(as)'
      captures:
        1: entity.other.aliased.function.constructor.gleam
        2: keyword.other.alias.gleam
      set: import--unqualified--item--variant--alias
    - match: '{{upname}}'
      scope: entity.name.function.constructor.gleam
      pop: true
    - include: req-item-brace

  import--unqualified--item--variant--alias:
    - include: ws
    - match: '{{upname}}'
      scope: entity.name.function.constructor.gleam
      pop: true
    - include: req

  import--unqualified--item--constant:
    - include: ws
    - match: '({{name}})\s+(as)'
      captures:
        1: entity.other.aliased.constant.gleam
        2: keyword.other.alias.gleam
      set: import--unqualified--item--constant--alias
    - match: '{{name}}'
      scope: entity.name.constant.gleam
      pop: true
    - include: req-item-brace

  import--unqualified--item--constant--alias:
    - include: ws
    - match: '{{name}}'
      scope: entity.name.constant.gleam
      pop: true
    - include: req-item-brace

  import--unqualified--post:
    - include: ws-lf
    - include: end-brace
    - match: ','
      scope: punctuation.separator.gleam
      set: import--unqualified--pre
    - include: req

  # ==== Visibility modifiers

  pub:
    - match: pub\b
      scope: storage.modifier.public.gleam
      push:
        - include: const
        - include: req

  # ==== Constants

  const:
    - match: const\b
      scope: keyword.declaration.constant.gleam
      push: const--name

  const--name:
    - include: ws
    - include: no-keyword
    - match: '{{name}}'
      scope: entity.name.constant.gleam
      set:
        - const--assignment
        - const--type
    - include: req

  const--type:
    - include: opt

  const--assignment:
    - include: ws
    - match: '='
      scope: keyword.operator.assignment.gleam
      # NOTE: We don't currently restrict constant values to only the
      # expressions that are valid in constants; any expression unit is
      # allowed, similar to `let`. The only negative effect is that some
      # constant expressions which are not valid syntax will be scoped as
      # though they are.
      set:
        - include: ws-lf
        - include: expression-unit
        - include: req
    - include: req

  # ==== Common

  end-brace:
    - match: '}'
      scope: punctuation.definition.generic.end.gleam
      pop: true

  end-bracket:
    - match: ']'
      scope: punctuation.definition.generic.end.gleam
      pop: true

  end-paren:
    - match: '\)'
      scope: punctuation.definition.generic.end.gleam
      pop: true

  expression-unit:
    - include: string
    - include: float
    - include: integer
    - include: tuple
    - include: list

  float:
    - match: '-?[0-9_]+\.[0-9_]*(e-?[0-9_]+)?\b'
      scope: constant.numeric.float.decimal.gleam
      pop: true

  integer:
    - match: -?0[bB][0-1_]+\b
      scope: constant.numeric.integer.binary.gleam
      pop: true
    - match: -?0[oO][0-7_]+\b
      scope: constant.numeric.integer.octal.gleam
      pop: true
    - match: -?[0-9][0-9_]*\b
      scope: constant.numeric.integer.decimal.gleam
      pop: true
    - match: -?0[xX][0-9a-fA-F_]+\b
      scope: constant.numeric.integer.hexadecimal.gleam
      pop: true

  list:
    - match: '\['
      scope: punctuation.definition.generic.begin.gleam
      push: list--pre

  list--pre:
    - include: ws-lf
    - include: end-bracket
    - include: --list--spread
    - match: ''
      set:
        - list--post
        - list--item

  list--item:
    - include: ws-lf
    - include: expression-unit
    - include: req-item-bracket

  list--post:
    - include: ws-lf
    - include: end-bracket
    - include: --list--spread
    - match: ','
      scope: punctuation.separator.gleam
      set: list--pre
    - include: req

  --list--spread:
    - match: '\.\.'
      scope: keyword.operator.spread.gleam
      set:
        - list--end
        - list--tail

  # TODO: Allowing _any_ expression as the tail of a list seems too permissive
  # (e.g. a tuple literal is clearly invalid), though that's how the tree-sitter
  # grammar does it.
  list--tail:
    - include: expression-unit
    - include: req

  list--end:
    - include: ws-lf
    - include: end-bracket
    - include: req

  string:
    - match: '"'
      scope: punctuation.definition.string.begin.gleam
      set:
        - meta_include_prototype: false
        - meta_scope: string.quoted.double.gleam
        - match: \\
          scope: constant.character.escape.gleam
          push: string--escape
        - match: '"'
          scope: punctuation.definition.string.end.gleam
          pop: true

  string--escape:
    - match: '[fnrt"\\]'
      scope: constant.character.escape.gleam
    - match: u\{[[:xdigit:]]{1,6}\}
      scope: constant.character.escape.gleam
    - include: req

  tuple:
    - match: '#\('
      scope: punctuation.definition.generic.begin.gleam
      push: tuple--pre

  tuple--pre:
    - include: ws-lf
    - include: end-paren
    - match: ''
      set:
        - tuple--post
        - tuple--item

  tuple--item:
    - include: ws-lf
    - include: expression-unit
    - include: req-item-paren

  tuple--post:
    - include: ws-lf
    - include: end-paren
    - match: ','
      scope: punctuation.separator.gleam
      set: tuple--pre
    - include: req

  # # Attributes (annotations)
  # attribute:
  #   - match: ^\s*(@{{lower_ident}})\(
  #     captures:
  #       1: variable.other.constant.gleam
  #     push:
  #       - include: arguments
  #       - meta_scope: meta.annotation.gleam
  #   - match: ^\s*(@{{lower_ident}})
  #     scope: meta.annotation.gleam
  #     captures:
  #       1: variable.other.constant.gleam

  # # Arguments (to a function call, record constructor, or attribute)
  # arguments:
  #   - include: bitstring
  #   - include: block
  #   - include: comment
  #   - include: function_def
  #   - include: function_call
  #   - include: record
  #   - include: number
  #   - include: operator
  #   - include: punctuation
  #   - include: string
  #   - include: unused_name
  #   - include: type_name
  #   - match: '\b{{lower_ident}}:'
  #     scope: constant.other.gleam
  #   - match: \)
  #     pop: true

  # # Bitstrings
  # bitstring:
  #   - match: '<<'
  #     scope: punctuation.definition.generic.begin.gleam
  #     push:
  #       - include: number
  #       - include: string
  #       - match: \b(bytes|int|float|bits|utf8|utf16|utf32|utf8_codepoint|utf16_codepoint|utf32_codepoint|signed|unsigned|big|little|native|unit|size)\b
  #         scope: keyword.other.gleam
  #       - match: '>>'
  #         scope: punctuation.definition.generic.end.gleam
  #         pop: true

  # # Blocks
  # block:
  #   - match: '{'
  #     scope: punctuation.section.block.begin.gleam
  #   - match: '}'
  #     scope: punctuation.section.block.end.gleam

  # # Function calls
  # function_call:
  #   - match: \b(?:{{lower_ident}}\.)*({{lower_ident}})\(
  #     captures:
  #       1: variable.function.gleam
  #     push: arguments

  # # Function definitions
  # function_def:
  #   - match: \b(fn)(?:[[:space:]]+({{lower_ident}}))?[[:space:]]*\(
  #     captures:
  #       1: storage.type.function.gleam
  #       2: entity.name.function.gleam
  #     push: function_def_args
  #   - match: ->
  #     scope: keyword.declaration.function.gleam

  # # Function arguments
  # function_def_args:
  #   - include: function_def
  #   - include: punctuation
  #   - include: type_name
  #   - include: unused_name
  #   - match: \b(?:({{lower_ident}})[[:space:]]+)?({{lower_ident}}:)
  #     captures:
  #       1: constant.other.gleam
  #       2: variable.parameter.gleam
  #   - match: \(
  #     push: function_def_args
  #   - match: \)
  #     pop: true

  # # Keywords
  # keyword:
  #   - match: \b(as|assert|case|const|let|panic|todo|use)\b
  #     scope: keyword.other.gleam
  #   - match: \b(opaque|pub)\b
  #     scope: storage.modifier.gleam
  #   - match: \btype\b
  #     scope: storage.type.gleam
  #   - match: \bfn\b
  #     scope: storage.type.function.gleam
  #   # Reserved for future use
  #   - match: \b(auto|delegate|derive|echo|else|implement|macro|test)\b
  #     scope: invalid.illegal.gleam

  # # Operators
  # operator:
  #   - match: (\|>|\.\.|<=\.|>=\.|==\.|!=\.|<\.|>\.|<=|>=|==|!=|<|>|<>|\|)
  #     scope: keyword.operator.gleam
  #   - match: (\+\.|\-\.|/\.|\*\.|%\.|\+|\-|/|\*|%)
  #     scope: keyword.operator.arithmetic.gleam
  #   - match: (=|<-)
  #     scope: keyword.operator.assignment.gleam
  #   - match: (&&|\|\|)
  #     scope: keyword.operator.logical.gleam

  # # Punctuation (separators, accessors)
  # punctuation:
  #   - match: \.
  #     scope: punctuation.accessor.gleam
  #   - match: ','
  #     scope: punctuation.separator.gleam

  # # Records (constructors with arguments)
  # record:
  #   - match: \b((?:{{lower_ident}}\.)*{{upper_ident}})\(
  #     captures:
  #       1: entity.name.type.gleam
  #     push: arguments

  # # Types and constructors
  # type_name:
  #   - match: \b(?:{{lower_ident}}\.)*{{upper_ident}}\b
  #     scope: entity.name.type.gleam

  # # Unused bindings
  # unused_name:
  #   - match: \b_{{lower_ident}}\b
  #     scope: comment.line.gleam
